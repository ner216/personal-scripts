#!/usr/bin/env python3

# Built in imports
import os
import subprocess
import sys
import argparse

# Get user who is running script
original_user = os.environ.get('SUDO_USER') or os.getlogin()

# Global variables
DEFAULT_SEARCH = [
    f"/home/{original_user}/Git/",
    f"/home/{original_user}/git/",
    f"/home/{original_user}/src/",
    f"/home/{original_user}/Src/",
    f"/home/{original_user}/dev/",
    f"/home/{original_user}/Dev/",
    f"/home/{original_user}/projects/",
    f"/home/{original_user}/Projects/",
    f"/home/{original_user}/project/",
    f"/home/{original_user}/Project/"
]
HOME_SEARCH = [f"/home/{original_user}/"]

# ANSI colors
YELLOW = "\033[33m"
BLUE = "\033[34m"
RED = "\033[31m"
RESET = "\033[0m" #Reset default to color

# A wrapper for the find_repositories_recursive which allows for the search of multiple parent directories
def find_repositories(directory_list: list, level_limit: int = 0) -> list: 
    repositories = []
    
    for directory in directory_list:
            repositories.extend(find_repositories_recursive(directory, level_limit))
    
    return repositories
    
# A recursive function that walks(iterates) through directories to find '.git' directories
def find_repositories_recursive(root: str, level_limit: int = 0, repositories: list = None, level: int = 0):
    if level_limit != 0 and level_limit == level:
        return repositories

    if repositories == None:
        repositories = []
    
    if os.path.isdir(root):
        os.chdir(root)
        for child_directory in os.listdir(root):
            child_path = f"{root}{child_directory}"
            if os.path.isdir(child_path + "/.git"):
                repositories.append(child_path)
            elif os.path.isdir(child_path) and child_directory[0] != ".":
                find_repositories_recursive(child_path + "/", level_limit, repositories, level)
    return repositories

def status_repos(repositories: list) -> None:
    for repo in repositories:
        print(f"{YELLOW}[GITY] -> Executing git status on [{repo}]{RESET}")
        try:
            os.chdir(repo)
            status_result = subprocess.run(['git', 'status'], capture_output=True, text=True)
            return_code = subprocess.call(['git', 'status'])
        except Exception as e:
            print(f"{RED}[GITY] -> Error, unable to execute git status on {repo}\n Exception: {e}{RESET}")

def main():
    parser = argparse.ArgumentParser(description="Run git-status on all local repositories at once. Without arguments, Gity will search directories specified in 'gity --list' up to 3 levels.")
    
    parser.add_argument("-l", "--list", action="store_true", help="List all repositories Gity found in the current home directory.")
    parser.add_argument("--show-default", action="store_true", help="Show search paths Gity will use when no arguments are given.")
    parser.add_argument("-a", "--all", action="store_true", help="Recursivly search entire home directory rather than default directories.")
    
    args = parser.parse_args()
    
    if len(sys.argv) == 1:
        local_repositories = find_repositories(DEFAULT_SEARCH, level_limit = 3)
        # Execute git status on discovered repos
        status_repos(local_repositories)
    elif args.list:
        print(f"{YELLOW}All repositories in your home directory:{RESET}")
        for repo in find_repositories(HOME_SEARCH):
            print(f" -- {repo}")
    elif args.show_default:
        print("By default with no options, Gity will only search the following directories up to 3 levels:")
        for repo in DEFAULT_SEARCH:
            print(f" -- {repo}")
    elif args.all:
        local_repositories = find_repositories(HOME_SEARCH)
        # Execute git status on discovered repos
        status_repos(local_repositories)
    
        

main()

